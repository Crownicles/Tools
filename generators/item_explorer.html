<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crownicles Item Explorer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        select, button, input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background-color: #3498db;
            color: white;
            cursor: pointer;
            border: none;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .item-type-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .type-btn {
            padding: 8px 16px;
            background-color: #ecf0f1;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            color: #333;
        }
        .type-btn.active {
            background-color: #3498db;
            color: white;
        }
        #loading {
            text-align: center;
            margin: 20px 0;
            display: none;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 2s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .progress-bar {
            width: 100%;
            background-color: #f3f3f3;
            height: 20px;
            border-radius: 4px;
            margin-top: 10px;
        }
        .progress {
            height: 100%;
            background-color: #3498db;
            border-radius: 4px;
            width: 0%;
            transition: width 0.3s;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 14px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
            cursor: pointer;
            user-select: none;
        }
        th:hover {
            background-color: #e0e0e0;
        }
        th.sorted-asc::after {
            content: " ▲";
            font-size: 0.8em;
        }
        th.sorted-desc::after {
            content: " ▼";
            font-size: 0.8em;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        tr:hover {
            background-color: #f1f1f1;
        }
        .table-container {
            flex-grow: 1;
            overflow-y: auto;
            margin-top: 20px;
            max-height: calc(100vh - 350px);
            min-height: 400px;
        }
        .rarity-0 { color: #777; } /* Basic */
        .rarity-1 { color: #222; } /* Common */
        .rarity-2 { color: #2ecc71; } /* Uncommon */
        .rarity-3 { color: #3498db; } /* Exotic */
        .rarity-4 { color: #9b59b6; } /* Rare */
        .rarity-5 { color: #e67e22; } /* Special */
        .rarity-6 { color: #f1c40f; } /* Epic */
        .rarity-7 { color: #e74c3c; } /* Legendary */
        .rarity-8 { color: #1abc9c; } /* Mythical */
        .search-box {
            flex-grow: 1;
            max-width: 300px;
        }
        .stat-info {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        .filter-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        .stats-display {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .stat-card {
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 15px;
            min-width: 200px;
            flex: 1;
        }
        .stat-card h3 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        .api-status {
            margin-top: 10px;
            font-size: 12px;
            color: #7f8c8d;
        }
        .api-status.warning {
            color: #e74c3c;
        }
        
        /* Conditional coloring styles */
        .color-toggle {
            margin-left: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .color-toggle input[type="checkbox"] {
            margin: 0;
        }
        
        .color-toggle label {
            font-size: 14px;
            cursor: pointer;
            user-select: none;
        }
        
        /* Color coding for stats */
        .stat-excellent { background-color: #d4edda !important; } /* Green for top 20% */
        .stat-good { background-color: #fff3cd !important; } /* Yellow for top 40% */
        .stat-poor { background-color: #f8d7da !important; } /* Red for bottom 20% */
        
        /* Legend for color coding */
        .color-legend {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            font-size: 12px;
        }
        
        .color-legend.visible {
            display: block;
        }
        
        .legend-item {
            display: inline-block;
            margin-right: 15px;
            padding: 2px 8px;
            border-radius: 3px;
            margin-bottom: 5px;
        }
        
        /* Column visibility */
        .column-hidden {
            display: none !important;
        }
        
        /* Column headers with data attributes for better control */
        th[data-column="rawAttack"] { }
        th[data-column="rawDefense"] { }
        th[data-column="rawSpeed"] { }
        th[data-column="finalAttack"] { }
        th[data-column="finalDefense"] { }
        th[data-column="speed"] { }
        th[data-column="nature"] { }
    </style>
</head>
<body>
    <div class="container">
        <h1>Crownicles Item Explorer</h1>
        
        <div class="controls">
            <select id="branch-select">
                <option value="master">master</option>
                <!-- Will be populated with branches -->
            </select>
            
            <button id="load-btn">Load Items</button>
            
            <button id="save-btn" disabled>Save Data</button>
            <input type="file" id="import-file" accept=".json" style="display: none;">
            <button id="import-btn">Import Data</button>
            
            <input type="text" id="search" class="search-box" placeholder="Search items...">
            
            <div style="flex-grow: 1;"></div>
            
            <div>
                <label for="rarity-filter">Rarity: </label>
                <select id="rarity-filter">
                    <option value="all">All</option>
                    <option value="0">Basic (0)</option>
                    <option value="1">Common (1)</option>
                    <option value="2">Uncommon (2)</option>
                    <option value="3">Exotic (3)</option>
                    <option value="4">Rare (4)</option>
                    <option value="5">Special (5)</option>
                    <option value="6">Epic (6)</option>
                    <option value="7">Legendary (7)</option>
                    <option value="8">Mythical (8)</option>
                </select>
            </div>
            
            <div class="color-toggle">
                <input type="checkbox" id="color-coding" />
                <label for="color-coding">Color Coding</label>
            </div>
        </div>
        
        <div class="color-legend" id="color-legend">
            <strong>Color Legend:</strong>
            <span class="legend-item stat-excellent">Top 20% (Excellent)</span>
            <span class="legend-item stat-good">Top 40% (Good)</span>
            <span class="legend-item stat-poor">Bottom 20% (Poor)</span>
        </div>
        
        <div class="item-type-selector">
            <button class="type-btn active" data-type="all">All Items</button>
            <button class="type-btn" data-type="weapons">Weapons</button>
            <button class="type-btn" data-type="armors">Armors</button>
            <button class="type-btn" data-type="objects">Objects</button>
            <button class="type-btn" data-type="potions">Potions</button>
        </div>
        
        <div id="loading">
            <div class="loader"></div>
            <p id="loading-status">Loading items data...</p>
            <div class="progress-bar">
                <div id="progress" class="progress"></div>
            </div>
            <div id="api-status" class="api-status"></div>
        </div>
        
        <div class="stats-display">
            <div class="stat-card">
                <h3>Items Loaded</h3>
                <p>Weapons: <span id="weapons-count">0</span></p>
                <p>Armors: <span id="armors-count">0</span></p>
                <p>Objects: <span id="objects-count">0</span></p>
                <p>Potions: <span id="potions-count">0</span></p>
                <p>Total: <span id="total-count">0</span></p>
            </div>
            
            <div class="stat-card">
                <h3>Rarity Distribution</h3>
                <div id="rarity-stats"></div>
            </div>
        </div>
        
        <div class="table-container">
            <table id="items-table">
                <thead>
                    <tr>
                        <th data-sort="id">ID</th>
                        <th data-sort="name">Name</th>
                        <th data-sort="rarity">Rarity</th>
                        <th data-sort="type">Type</th>
                        <th data-sort="rawAttack" data-column="rawAttack">Raw Attack</th>
                        <th data-sort="rawDefense" data-column="rawDefense">Raw Defense</th>
                        <th data-sort="attack" data-column="attack">Attack</th>
                        <th data-sort="defense" data-column="defense">Defense</th>
                        <th data-sort="speed" data-column="speed">Speed</th>
                        <th data-sort="nature" data-column="nature">Nature</th>
                        <th data-sort="power" data-column="power">Power</th>
                        <th data-sort="tags">Tags</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Items will be populated here -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Constants for rarity multipliers and calculations
        const RARITY_MULTIPLIERS = [1.0, 1.5, 2.1, 2.8, 3.6, 4.5, 5.5, 6.6, 6.7];
        const RARITY_NAMES = ["Basic", "Common", "Uncommon", "Exotic", "Rare", "Special", "Epic", "Legendary", "Mythical"];
        const NATURE_NAMES = ["None", "Health", "Speed", "Attack", "Defense", "Time Speedup", "Money", "Energy"];
        
        // Item data storage
        let allItems = {
            weapons: [],
            armors: [],
            objects: [],
            potions: []
        };
        
        // Cache for already loaded branches
        const itemCache = {};
        
        // Cache for item names from i18n
        let itemNames = {
            weapons: {},
            armors: {},
            objects: {},
            potions: {}
        };
        
        // DOM elements
        const branchSelect = document.getElementById('branch-select');
        const loadBtn = document.getElementById('load-btn');
        const saveBtn = document.getElementById('save-btn');
        const importBtn = document.getElementById('import-btn');
        const importFile = document.getElementById('import-file');
        const itemsTable = document.getElementById('items-table');
        const loadingIndicator = document.getElementById('loading');
        const loadingStatus = document.getElementById('loading-status');
        const progressBar = document.getElementById('progress');
        const apiStatus = document.getElementById('api-status');
        const typeButtons = document.querySelectorAll('.type-btn');
        const searchInput = document.getElementById('search');
        const rarityFilter = document.getElementById('rarity-filter');
        
        // Stats elements
        const weaponsCount = document.getElementById('weapons-count');
        const armorsCount = document.getElementById('armors-count');
        const objectsCount = document.getElementById('objects-count');
        const potionsCount = document.getElementById('potions-count');
        const totalCount = document.getElementById('total-count');
        const rarityStats = document.getElementById('rarity-stats');
        
        // Current state
        let currentType = 'all';
        let currentBranch = 'master'; // Changed from 'main' to 'master'
        let remainingApiCalls = 5000; // GitHub API default limit
        let currentSortColumn = 'id';
        let currentSortDirection = 'asc';
        
        // Initialize the app
        document.addEventListener('DOMContentLoaded', () => {
            loadBranches();
            
            // Event listeners
            loadBtn.addEventListener('click', loadItems);
            saveBtn.addEventListener('click', saveData);
            importBtn.addEventListener('click', () => importFile.click());
            importFile.addEventListener('change', importData);
            
            typeButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    typeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentType = btn.dataset.type;
                    updateColumnVisibility();
                    displayItems();
                });
            });
            
            searchInput.addEventListener('input', displayItems);
            rarityFilter.addEventListener('change', displayItems);
            
            // Color coding toggle
            const colorToggle = document.getElementById('color-coding');
            const colorLegend = document.getElementById('color-legend');
            
            colorToggle.addEventListener('change', () => {
                if (colorToggle.checked) {
                    colorLegend.classList.add('visible');
                } else {
                    colorLegend.classList.remove('visible');
                    // Remove all color classes
                    const allCells = itemsTable.querySelectorAll('td');
                    allCells.forEach(cell => {
                        cell.classList.remove('stat-excellent', 'stat-good', 'stat-poor');
                    });
                }
                displayItems();
            });
            
            // Setup column sorting
            setupSorting();
            
            // Initialize column visibility
            updateColumnVisibility();
        });
        
        // Setup sorting functionality
        function setupSorting() {
            const headers = itemsTable.querySelectorAll('th[data-sort]');
            
            headers.forEach(header => {
                header.addEventListener('click', () => {
                    const column = header.dataset.sort;
                    
                    // If clicking the same column, toggle direction
                    if (column === currentSortColumn) {
                        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        // New column, default to ascending
                        currentSortColumn = column;
                        currentSortDirection = 'asc';
                    }
                    
                    // Update header classes
                    headers.forEach(h => {
                        h.classList.remove('sorted-asc', 'sorted-desc');
                    });
                    
                    header.classList.add(`sorted-${currentSortDirection}`);
                    
                    // Re-display items with new sort
                    displayItems();
                });
            });
        }
        
        // Load branches from GitHub
        async function loadBranches() {
            try {
                const response = await fetch('https://api.github.com/repos/Crownicles/Crownicles/branches');
                updateApiRateLimit(response);
                
                if (!response.ok) throw new Error('Failed to fetch branches');
                
                const branches = await response.json();
                
                // Clear existing options except the first one (master)
                while (branchSelect.options.length > 1) {
                    branchSelect.remove(1);
                }
                
                // Add branches
                branches.forEach(branch => {
                    if (branch.name !== 'master') { // Skip master as it's already there
                        const option = document.createElement('option');
                        option.value = branch.name;
                        option.textContent = branch.name;
                        branchSelect.appendChild(option);
                    }
                });
            } catch (error) {
                console.error('Error loading branches:', error);
                alert('Failed to load branches. Please try again later.');
            }
        }
        
        // Update API rate limit info
        function updateApiRateLimit(response) {
            if (response.headers.has('X-RateLimit-Remaining')) {
                remainingApiCalls = parseInt(response.headers.get('X-RateLimit-Remaining'));
                
                apiStatus.textContent = `GitHub API calls remaining: ${remainingApiCalls}`;
                
                if (remainingApiCalls < 100) {
                    apiStatus.classList.add('warning');
                } else {
                    apiStatus.classList.remove('warning');
                }
            }
        }
        
        // Load item names from i18n file
        async function loadItemNames(branch) {
            try {
                loadingStatus.textContent = 'Loading item names from i18n...';
                
                const response = await fetch(`https://raw.githubusercontent.com/Crownicles/Crownicles/${branch}/Lang/fr/models.json`);
                updateApiRateLimit(response);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch i18n file: ${response.status}`);
                }
                
                const i18nData = await response.json();
                
                // Extract item names
                itemNames.weapons = i18nData.weapons || {};
                itemNames.armors = i18nData.armors || {};
                itemNames.objects = i18nData.objects || {};
                itemNames.potions = i18nData.potions || {};
                
                console.log('Loaded item names:', {
                    weapons: Object.keys(itemNames.weapons).length,
                    armors: Object.keys(itemNames.armors).length,
                    objects: Object.keys(itemNames.objects).length,
                    potions: Object.keys(itemNames.potions).length
                });
                
            } catch (error) {
                console.warn('Failed to load item names from i18n:', error);
                // Continue without names - will use generated ones
            }
        }
        
        // Load items from the selected branch
        async function loadItems() {
            currentBranch = branchSelect.value;
            
            // Check if we already have the data for this branch in cache
            if (itemCache[currentBranch]) {
                allItems = JSON.parse(JSON.stringify(itemCache[currentBranch])); // Deep clone
                updateStats();
                displayItems();
                saveBtn.disabled = false;
                return;
            }
            
            loadingIndicator.style.display = 'block';
            loadBtn.disabled = true;
            progressBar.style.width = '0%';
            
            try {
                // Reset item data
                allItems = {
                    weapons: [],
                    armors: [],
                    objects: [],
                    potions: []
                };
                
                // Load item names from i18n first
                await loadItemNames(currentBranch);
                
                // Item type metadata
                const itemTypes = [
                    { type: 'weapons', count: 99 },
                    { type: 'armors', count: 65 },
                    { type: 'objects', count: 93 },
                    { type: 'potions', count: 50 }
                ];
                
                // Get all directory contents in a more efficient way
                for (let i = 0; i < itemTypes.length; i++) {
                    const { type, count } = itemTypes[i];
                    
                    loadingStatus.textContent = `Loading ${type} directory...`;
                    
                    // Fetch the directory contents to get all files at once
                    const dirResponse = await fetch(
                        `https://api.github.com/repos/Crownicles/Crownicles/contents/Core/resources/${type}?ref=${currentBranch}`
                    );
                    updateApiRateLimit(dirResponse);
                    
                    if (!dirResponse.ok) {
                        throw new Error(`Failed to fetch ${type} directory: ${dirResponse.status}`);
                    }
                    
                    const files = await dirResponse.json();
                    
                    // Sort files by filename (numerical order)
                    files.sort((a, b) => {
                        const numA = parseInt(a.name.split('.')[0]);
                        const numB = parseInt(b.name.split('.')[0]);
                        return numA - numB;
                    });
                    
                    // Load items in batches to be more efficient
                    const BATCH_SIZE = 10;
                    const batches = Math.ceil(files.length / BATCH_SIZE);
                    
                    for (let j = 0; j < batches; j++) {
                        const batchFiles = files.slice(j * BATCH_SIZE, (j + 1) * BATCH_SIZE);
                        
                        // Create promises for all files in batch
                        const batchPromises = batchFiles.map(file => {
                            return fetch(file.download_url)
                                .then(res => res.json())
                                .then(item => {
                                    const id = parseInt(file.name.split('.')[0]);
                                    item.id = id;
                                    item.type = type.slice(0, -1); // Remove 's' to get singular form
                                    
                                    // Get name from i18n or generate default
                                    const i18nName = itemNames[type] && itemNames[type][id.toString()];
                                    if (i18nName) {
                                        item.name = i18nName;
                                    } else {
                                        const typeName = item.type.charAt(0).toUpperCase() + item.type.slice(1);
                                        item.name = `${typeName} ${id}`;
                                    }
                                    
                                    // Calculate final stats
                                    if (type === 'weapons') {
                                        calculateWeaponStats(item);
                                    } else if (type === 'armors') {
                                        calculateArmorStats(item);
                                    } else if (type === 'objects') {
                                        calculateObjectStats(item);
                                    } else if (type === 'potions') {
                                        calculatePotionStats(item);
                                    }
                                    
                                    return item;
                                })
                                .catch(err => {
                                    console.warn(`Failed to load ${type} item ${file.name}:`, err);
                                    return null;
                                });
                        });
                        
                        // Wait for all files in batch to load
                        const batchResults = await Promise.all(batchPromises);
                        
                        // Add valid items to the array
                        batchResults.filter(item => item !== null).forEach(item => {
                            allItems[type].push(item);
                        });
                        
                        // Update progress
                        const overallProgress = (
                            (i / itemTypes.length) + 
                            ((j + 1) / batches / itemTypes.length)
                        ) * 100;
                        
                        progressBar.style.width = `${overallProgress}%`;
                        loadingStatus.textContent = `Loading ${type}: ${allItems[type].length}/${count} items (batch ${j+1}/${batches})`;
                    }
                }
                
                // Cache the loaded data
                itemCache[currentBranch] = JSON.parse(JSON.stringify(allItems));
                
                // Update stats
                updateStats();
                
                // Display items
                displayItems();
                
                // Enable save button
                saveBtn.disabled = false;
                
                loadingStatus.textContent = 'All items loaded successfully!';
                setTimeout(() => {
                    loadingIndicator.style.display = 'none';
                }, 1000);
                
            } catch (error) {
                console.error('Error loading items:', error);
                loadingStatus.textContent = `Error: ${error.message}`;
                alert('Failed to load items. Please check console for details.');
            } finally {
                loadBtn.disabled = false;
            }
        }
        
        // Save data to JSON file
        function saveData() {
            if (!allItems || Object.keys(allItems).length === 0) {
                alert('No data to save. Please load items first.');
                return;
            }
            
            const dataToSave = {
                branch: currentBranch,
                timestamp: new Date().toISOString(),
                items: allItems,
                version: '1.0'
            };
            
            const dataStr = JSON.stringify(dataToSave, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `crownicles-items-${currentBranch}-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        // Import data from JSON file
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Validate the imported data structure
                    if (!importedData.items || !importedData.branch) {
                        throw new Error('Invalid file format. Missing required fields.');
                    }
                    
                    if (!importedData.items.weapons || !importedData.items.armors || !importedData.items.objects || !importedData.items.potions) {
                        throw new Error('Invalid file format. Missing item types.');
                    }
                    
                    // Load the imported data
                    allItems = importedData.items;
                    currentBranch = importedData.branch;
                    
                    // Update the branch selector
                    branchSelect.value = currentBranch;
                    
                    // Cache the imported data
                    itemCache[currentBranch] = JSON.parse(JSON.stringify(allItems));
                    
                    // Update UI
                    updateStats();
                    displayItems();
                    
                    // Enable save button
                    saveBtn.disabled = false;
                    
                    alert(`Successfully imported ${allItems.weapons.length + allItems.armors.length + allItems.objects.length + allItems.potions.length} items from branch "${currentBranch}"\nImported on: ${importedData.timestamp}`);
                    
                } catch (error) {
                    console.error('Error importing data:', error);
                    alert(`Failed to import data: ${error.message}`);
                }
            };
            
            reader.readAsText(file);
            
            // Reset the file input
            event.target.value = '';
        }
        
        // Calculate weapon stats
        function calculateWeaponStats(item) {
            const multiplier = RARITY_MULTIPLIERS[item.rarity] || 1;
            
            // Weapons have rawAttack and optional defense/speed bonuses
            item.rawAttack = item.rawAttack || 0;
            item.rawDefense = 0; // Weapons never have raw defense
            
            // Calculate attack (final attack for weapons)
            if (item.rawAttack) {
                item.attack = Math.round(1.15053 * Math.pow(multiplier, 2.3617) * 
                                       Math.pow(1.0569 + 0.1448 / multiplier, item.rawAttack));
            } else {
                item.attack = 0;
            }
            
            // Load actual defense and speed bonuses from JSON (not calculated)
            item.defense = item.defense || 0;
            item.speed = item.speed || 0;
        }
        
        // Calculate armor stats
        function calculateArmorStats(item) {
            const multiplier = RARITY_MULTIPLIERS[item.rarity] || 1;
            
            // Armors have rawDefense and optional attack/speed bonuses
            item.rawDefense = item.rawDefense || 0;
            item.rawAttack = 0; // Armors never have raw attack
            
            // Calculate defense (final defense for armors)
            if (item.rawDefense) {
                item.defense = Math.round(1.15053 * Math.pow(multiplier, 2.3617) * 
                                        Math.pow(1.0569 + 0.1448 / multiplier, item.rawDefense));
            } else {
                item.defense = 0;
            }
            
            // Load actual attack and speed bonuses from JSON (not calculated)
            item.attack = item.attack || 0;
            item.speed = item.speed || 0;
        }
        
        // Calculate object stats
        function calculateObjectStats(item) {
            item.power = item.power || 0;
            item.nature = item.nature || 0;
            
            // Objects provide direct stat bonuses based on their nature
            if (item.nature === 3) { // ATTACK
                item.finalAttack = item.power;
                item.finalDefense = 0;
                item.finalSpeed = 0;
            } else if (item.nature === 4) { // DEFENSE
                item.finalAttack = 0;
                item.finalDefense = item.power;
                item.finalSpeed = 0;
            } else if (item.nature === 2) { // SPEED
                item.finalAttack = 0;
                item.finalDefense = 0;
                item.finalSpeed = item.power;
            } else {
                item.finalAttack = 0;
                item.finalDefense = 0;
                item.finalSpeed = 0;
            }
        }
        
        // Calculate potion stats
        function calculatePotionStats(item) {
            item.power = item.power || 0;
            item.nature = item.nature || 0;
            
            // Potions provide temporary boosts based on their nature
            if (item.nature === 3) { // ATTACK
                item.finalAttack = item.power;
                item.finalDefense = 0;
                item.finalSpeed = 0;
            } else if (item.nature === 4) { // DEFENSE
                item.finalAttack = 0;
                item.finalDefense = item.power;
                item.finalSpeed = 0;
            } else if (item.nature === 2) { // SPEED
                item.finalAttack = 0;
                item.finalDefense = 0;
                item.finalSpeed = item.power;
            } else {
                item.finalAttack = 0;
                item.finalDefense = 0;
                item.finalSpeed = 0;
            }
        }
        
        // Compare function for sorting
        function compareItems(a, b, column, direction) {
            let valueA, valueB;
            
            // Handle special columns
            if (column === 'name') {
                valueA = (a.name || '').toLowerCase();
                valueB = (b.name || '').toLowerCase();
            } else if (column === 'tags') {
                valueA = (a.tags ? a.tags.join(',') : '').toLowerCase();
                valueB = (b.tags ? b.tags.join(',') : '').toLowerCase();
            } else if (column === 'nature') {
                valueA = NATURE_NAMES[a.nature] || '';
                valueB = NATURE_NAMES[b.nature] || '';
            } else {
                valueA = a[column] || 0;
                valueB = b[column] || 0;
            }
            
            // Compare
            if (valueA < valueB) {
                return direction === 'asc' ? -1 : 1;
            }
            if (valueA > valueB) {
                return direction === 'asc' ? 1 : -1;
            }
            return 0;
        }
        
        // Update column visibility based on current type
        function updateColumnVisibility() {
            const table = itemsTable;
            const headers = table.querySelectorAll('th[data-column]');
            const rows = table.querySelectorAll('tbody tr');
            
            // Reset all columns to visible first
            headers.forEach(header => {
                header.classList.remove('column-hidden');
            });
            
            // Hide/show columns based on type
            if (currentType === 'weapons') {
                // Weapons: show rawAttack and attack (calculated), hide rawDefense
                // Show defense and speed (optional bonuses)
                table.querySelector('th[data-column="rawDefense"]').classList.add('column-hidden');
                table.querySelector('th[data-column="power"]').classList.add('column-hidden');
                table.querySelector('th[data-column="nature"]').classList.add('column-hidden');
            } else if (currentType === 'armors') {
                // Armors: show rawDefense and defense (calculated), hide rawAttack
                // Show attack and speed (optional bonuses)
                table.querySelector('th[data-column="rawAttack"]').classList.add('column-hidden');
                table.querySelector('th[data-column="power"]').classList.add('column-hidden');
                table.querySelector('th[data-column="nature"]').classList.add('column-hidden');
            } else if (currentType === 'objects' || currentType === 'potions') {
                // Objects/Potions: hide all raw stats and attack/defense, show power and nature
                table.querySelector('th[data-column="rawAttack"]').classList.add('column-hidden');
                table.querySelector('th[data-column="rawDefense"]').classList.add('column-hidden');
                table.querySelector('th[data-column="attack"]').classList.add('column-hidden');
                table.querySelector('th[data-column="defense"]').classList.add('column-hidden');
                table.querySelector('th[data-column="speed"]').classList.add('column-hidden');
            }
            // For 'all' type, show everything
            
            // Update cell visibility for existing rows
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                // Reset all cells
                cells.forEach(cell => cell.classList.remove('column-hidden'));
                
                if (currentType === 'weapons') {
                    if (cells[5]) cells[5].classList.add('column-hidden'); // rawDefense
                    if (cells[9]) cells[9].classList.add('column-hidden'); // nature
                    if (cells[10]) cells[10].classList.add('column-hidden'); // power
                } else if (currentType === 'armors') {
                    if (cells[4]) cells[4].classList.add('column-hidden'); // rawAttack
                    if (cells[9]) cells[9].classList.add('column-hidden'); // nature
                    if (cells[10]) cells[10].classList.add('column-hidden'); // power
                } else if (currentType === 'objects' || currentType === 'potions') {
                    if (cells[4]) cells[4].classList.add('column-hidden'); // rawAttack
                    if (cells[5]) cells[5].classList.add('column-hidden'); // rawDefense
                    if (cells[6]) cells[6].classList.add('column-hidden'); // attack
                    if (cells[7]) cells[7].classList.add('column-hidden'); // defense
                    if (cells[8]) cells[8].classList.add('column-hidden'); // speed
                }
            });
        }
        
        // Display items in the table
        function displayItems() {
            const tbody = itemsTable.querySelector('tbody');
            tbody.innerHTML = '';
            
            // Get filters
            const searchTerm = searchInput.value.toLowerCase();
            const rarityValue = rarityFilter.value;
            const colorCodingEnabled = document.getElementById('color-coding').checked;
            
            // Combine items based on current type filter
            let itemsToDisplay = [];
            if (currentType === 'all') {
                itemsToDisplay = [
                    ...allItems.weapons,
                    ...allItems.armors,
                    ...allItems.objects,
                    ...allItems.potions
                ];
            } else {
                itemsToDisplay = allItems[currentType];
            }
            
            // Apply filters
            itemsToDisplay = itemsToDisplay.filter(item => {
                // Search filter
                const nameMatch = item.name && item.name.toLowerCase().includes(searchTerm);
                const idMatch = item.id.toString().includes(searchTerm);
                
                // Rarity filter
                const rarityMatch = rarityValue === 'all' || item.rarity.toString() === rarityValue;
                
                return (nameMatch || idMatch) && rarityMatch;
            });
            
            // Sort items by the selected column and direction
            itemsToDisplay.sort((a, b) => compareItems(a, b, currentSortColumn, currentSortDirection));
            
            // Create table rows
            itemsToDisplay.forEach(item => {
                const tr = document.createElement('tr');
                
                tr.innerHTML = `
                    <td>${item.id}</td>
                    <td>${item.name || 'N/A'}</td>
                    <td class="rarity-${item.rarity}">${RARITY_NAMES[item.rarity]} (${item.rarity})</td>
                    <td>${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</td>
                    <td class="${currentType === 'armors' || currentType === 'objects' || currentType === 'potions' ? 'column-hidden' : ''}">${item.rawAttack || '0'}</td>
                    <td class="${currentType === 'weapons' || currentType === 'objects' || currentType === 'potions' ? 'column-hidden' : ''}">${item.rawDefense || '0'}</td>
                    <td class="${currentType === 'objects' || currentType === 'potions' ? 'column-hidden' : ''}">${item.attack || '0'}</td>
                    <td class="${currentType === 'objects' || currentType === 'potions' ? 'column-hidden' : ''}">${item.defense || '0'}</td>
                    <td class="${currentType === 'objects' || currentType === 'potions' ? 'column-hidden' : ''}">${item.speed || '0'}</td>
                    <td class="${currentType === 'weapons' || currentType === 'armors' ? 'column-hidden' : ''}">${NATURE_NAMES[item.nature] || 'N/A'}</td>
                    <td class="${currentType === 'weapons' || currentType === 'armors' ? 'column-hidden' : ''}">${item.power || '0'}</td>
                    <td>${item.tags ? item.tags.join(', ') : ''}</td>
                `;
                
                tbody.appendChild(tr);
            });
            
            // Apply color coding if enabled
            if (colorCodingEnabled) {
                applyColorCoding();
            }
        }
        
        // Apply color coding to the displayed items
        function applyColorCoding() {
            const rows = itemsTable.querySelectorAll('tbody tr');
            if (rows.length === 0) return;
            
            // Collect all stat values for percentile calculation
            const stats = {
                rawAttack: [],
                rawDefense: [],
                attack: [],
                defense: [],
                speed: [],
                power: []
            };
            
            // Extract all values - corrected indices for fusioned structure
            rows.forEach(row => {
                stats.rawAttack.push(parseFloat(row.cells[4].textContent) || 0);
                stats.rawDefense.push(parseFloat(row.cells[5].textContent) || 0);
                stats.attack.push(parseFloat(row.cells[6].textContent) || 0);
                stats.defense.push(parseFloat(row.cells[7].textContent) || 0);
                stats.speed.push(parseFloat(row.cells[8].textContent) || 0);
                stats.power.push(parseFloat(row.cells[10].textContent) || 0);
            });
            
            // Calculate percentiles for each stat
            const percentiles = {};
            Object.keys(stats).forEach(statKey => {
                const sortedValues = stats[statKey].filter(val => val > 0).sort((a, b) => a - b);
                if (sortedValues.length > 0) {
                    percentiles[statKey] = {
                        p80: sortedValues[Math.floor(sortedValues.length * 0.8)] || 0,
                        p60: sortedValues[Math.floor(sortedValues.length * 0.6)] || 0,
                        p20: sortedValues[Math.floor(sortedValues.length * 0.2)] || 0
                    };
                } else {
                    percentiles[statKey] = { p80: 0, p60: 0, p20: 0 };
                }
            });
            
            // Apply color coding to each cell - corrected indices for fusioned structure
            rows.forEach(row => {
                const cellIndices = [4, 5, 6, 7, 8, 10]; // rawAttack, rawDefense, attack, defense, speed, power
                const statKeys = ['rawAttack', 'rawDefense', 'attack', 'defense', 'speed', 'power'];
                
                cellIndices.forEach((cellIndex, i) => {
                    const cell = row.cells[cellIndex];
                    const value = parseFloat(cell.textContent) || 0;
                    const statKey = statKeys[i];
                    
                    // Remove existing color classes
                    cell.classList.remove('stat-excellent', 'stat-good', 'stat-poor');
                    
                    if (value > 0 && percentiles[statKey]) {
                        if (value >= percentiles[statKey].p80) {
                            cell.classList.add('stat-excellent');
                        } else if (value >= percentiles[statKey].p60) {
                            cell.classList.add('stat-good');
                        } else if (value <= percentiles[statKey].p20) {
                            cell.classList.add('stat-poor');
                        }
                    }
                });
            });
        }
        
        // Update statistics
        function updateStats() {
            weaponsCount.textContent = allItems.weapons.length;
            armorsCount.textContent = allItems.armors.length;
            objectsCount.textContent = allItems.objects.length;
            potionsCount.textContent = allItems.potions.length;
            totalCount.textContent = allItems.weapons.length + allItems.armors.length + allItems.objects.length + allItems.potions.length;
            
            // Calculate rarity distribution
            const rarityDistribution = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            
            Object.values(allItems).forEach(itemType => {
                itemType.forEach(item => {
                    if (item.rarity >= 0 && item.rarity <= 8) {
                        rarityDistribution[item.rarity]++;
                    }
                });
            });
            
            // Display rarity distribution
            rarityStats.innerHTML = '';
            RARITY_NAMES.forEach((name, index) => {
                const percentage = Math.round((rarityDistribution[index] / parseInt(totalCount.textContent)) * 100) || 0;
                rarityStats.innerHTML += `<p class="rarity-${index}">${name} (${index}): ${rarityDistribution[index]} (${percentage}%)</p>`;
            });
        }
    </script>
</body>
</html>